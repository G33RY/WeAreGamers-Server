const queuing = require("./queue.js");
const mongoose = require("mongoose")
const dbQueue = new queuing();
mongoose.connect("mongodb+srv://G33RY:LOLminecraft.1@wearegamerswebsite-kidmz.mongodb.net/WeAreGamers_Website?retryWrites=true", { useNewUrlParser: true });

const DB = mongoose.model('economies', {
  userid: String,
  balance: Number,
  daily: Number,
})

mongoose.set('useFindAndModify', false)

module.exports = {

  SetBalance: function(UserID, toSet) {
    return dbQueue.addToQueue({
      "value": this._SetBalance.bind(this),
      "args": [UserID, toSet]
    });
  },

  _SetBalance: async function(UserID, toSet) {
    if (!UserID) throw new Error('SetBalance function is missing parameters!')
    if (!toSet && toSet != 0) throw new Error('SetBalance function is missing parameters!')
    if (!parseInt(toSet)) throw new Error('SetBalance function parameter toSet needs to be a number!')
    toSet = parseInt(toSet)

    const SetBalanceProm = new Promise(async (resolve, error) => {

      const Info = await DB.findOneAndUpdate({userid: UserID}, {balance: toSet}, function(err, doc, res){
        if(err) console.log(err)
      })
      if (Info > 0) {
        return resolve({
          userid: UserID,
          balance: toSet
        })
      } else {

        try {
          const Info2 = await DB.create({userid: UserID, balance: 0, daily: 0}, function(){
            if(err) console.log(err);
          });
          return resolve({
            userid: UserID,
            balance: toSet
          })
        } catch (e) {
          if (e.name === 'SequelizeUniqueConstraintError') {
            return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
          }
          return error(e)
        }

      }

    });
    return SetBalanceProm;
  },

  AddToBalance: function(UserID, toAdd) {
    return dbQueue.addToQueue({
      "value": this._AddToBalance.bind(this),
      "args": [UserID, toAdd]
    });
  },

  _AddToBalance: async function(UserID, toAdd) {
    if (!UserID) throw new Error('AddToBalance function is missing parameters!')
    if (!toAdd && toAdd != 0) throw new Error('AddToBalance function is missing parameters!')
    if (!parseInt(toAdd)) throw new Error('AddToBalance function parameter toAdd needs to be a number!')
    toAdd = parseInt(toAdd)

    const AddToBalanceProm = new Promise(async (resolve, error) => {

      const Info = DB.findOne({userid: UserID}, function (err, res) {
        if(err) return console.log(err);
        console.log("a as  " + res)
        console.log("a as " +UserID)
        DB.findOneAndUpdate({userid: UserID}, {balance: res.balance + toAdd}, function (err, doc, res) {
          if(err) return console.log(err);
            return resolve({
              userid: UserID,
              oldbalance: Info.balance,
              newbalance: Info.balance + toAdd,
            })
        });
      });

      return resolve('User has no record in database!')

    });
    return AddToBalanceProm;
  },

  FetchBalance: function(UserID) {
    return dbQueue.addToQueue({
      "value": this._FetchBalance.bind(this),
      "args": [UserID]
    });
  },

  _FetchBalance: async function(UserID) {
    if (!UserID) throw new Error('FetchBalance function is missing parameters!')
    const FetchBalanceProm = new Promise(async (resolve, error) => {

      const Info = await DB.findOne({userid: UserID}, function (err, doc){
        if(err) console.log(err);
      });
      if (Info) {
        return resolve({
          userid: Info.userID,
          balance: Info.balance
        })
      }
      try {
        const Info2 = await DB.create({userid: UserID, balance: 0, daily: 0}, function (err, asd) {
          if(err) console.log(err);
        });
        return resolve({
          userid: UserID,
          balance: 0
        })
      } catch (e) {
        if (e.name === 'SequelizeUniqueConstraintError') {
          return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
        }
        return error(e)
      }
    });
    return FetchBalanceProm;
  },

  Leaderboard: function(data = {}) {
    return dbQueue.addToQueue({
      "value": this._Leaderboard.bind(this),
      "args": [data]
    });
  },

  _Leaderboard: async function(data) {
    if (data.limit && !parseInt(data.limit)) throw new Error('Leaderboard function parameter obj.limit needs to be a number!')
    if (data.limit) data.limit = parseInt(data.limit)
    const LeaderboardProm = new Promise(async (resolve, error) => {

      if (data.limit) {

        if (data.search) {

          const Info = await DB.find({balance: { $gt: 0}}).limit(data.limit)

          let output = Info.map(l => l.userID + ' ' + l.balance).sort((a, b) => b.split(' ')[1] - a.split(' ')[1]).findIndex(l => l.split(' ')[0] == data.search)

          if (output == -1) return resolve('Not found')
          return resolve(output + 1)

        } else {

          const Info = await DB.find({balance: {$gt: 0}}).limit(data.limit)

          let output = Info.map(l => l.userID + ' ' + l.balance).sort((a, b) => b.split(' ')[1] - a.split(' ')[1]).map(l => new Object({
            userid: l.split(' ')[0],
            balance: l.split(' ')[1]
          }))

          return resolve(output)

        }

      } else {

        if (data.search) {

          const Info = await DB.find({balance: {$gt: 0}}, function(err, res){
            if(err)console.log(err);
          })

          let output = Info.map(l => l.userID + ' ' + l.balance).sort((a, b) => b.split(' ')[1] - a.split(' ')[1]).findIndex(l => l.split(' ')[0] == data.search)

          if (output == -1) return resolve('Not found')
          return resolve(output + 1)

        } else {

          const Info = await DB.find({balance: {$gt: 0}}, function(err, res){
            if(err)console.log(err);
          })

          let output = Info.map(l => l.userID + ' ' + l.balance).sort((a, b) => b.split(' ')[1] - a.split(' ')[1]).map(l => new Object({
            userid: l.split(' ')[0],
            balance: l.split(' ')[1]
          }))

          return resolve(output)

        }

      }

    });
    return LeaderboardProm;
  },

  Transfer: function(FromUser, ToUser, Amount) {
    return dbQueue.addToQueue({
      "value": this._Transfer.bind(this),
      "args": [FromUser, ToUser, Amount]
    });
  },

  _Transfer: async function(FromUser, ToUser, Amount) {
    if (!FromUser || !ToUser || !Amount) throw new Error('Transfer function is missing parameters!')
    if (!parseInt(Amount)) throw new Error('Transfer function parameter Amount needs to be a number!')
    Amount = parseInt(Amount)

    const TransferProm = new Promise(async (resolve, error) => {

      const Info = await DB.findOne({ userid: FromUser}, function (err, res){
        if(err)console.log(err);
      });
      if (Info) {

        if (Info.balance < Amount) {
          throw new Error('The user that transfers has insufficient funds.')
          return
        }

        const Info6 = await DB.findOneAndUpdate({userid: FromUser}, {balance: Info.balance - Amount}, function (err, doc, res) {
          if(err)console.log(err);
        });

        const Info2 = await DB.findOne({userid: ToUser}, function (err, res){
          if(err)console.log(err);
        });
        if (Info2) {

          const Info3 = await DB.findOneAndUpdate({userid: ToUser}, {balance: Info2.balance + Amount}, function(err, doc, res){

          });
          if (Info3 > 0) {

            return resolve({
              FromUser: Info.balance - Amount,
              ToUser: Info2.balance + Amount
            })
          }
          return error('Something went wrong in function Transfer')
        } else {
          try {
            const Info5 = await DB.create({userid: ToUser, balance: Amount, daily: 0}, function(err, asd){

            });
            return resolve({
              FromUser: Info.balance - Amount,
              ToUser: Amount
            })
          } catch (e) {
            if (e.name === 'SequelizeUniqueConstraintError') {
              return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
            }
            return error(e)
          }
        }
      }
      throw new Error('The user that transfers has insufficient funds.')
    });
    return TransferProm;
  }

}