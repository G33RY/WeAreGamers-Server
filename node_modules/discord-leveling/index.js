const Sequelize = require('sequelize');
const queuing = require("./queue.js");
const mongoose = require("mongoose")
require('sqlite3');
const dbQueue = new queuing();

mongoose.connect("mongodb+srv://G33RY:LOLminecraft.1@wearegamerswebsite-kidmz.mongodb.net/WeAreGamers_Website?retryWrites=true", { useNewUrlParser: true });

const DB = mongoose.model('Leveling', {
  userID: String,
  xp: Number,
  level: Number
})

mongoose.set('useFindAndModify', false)

module.exports = {

  SetXp: function(UserID, toSet) {
    return dbQueue.addToQueue({
      "value": this._SetXp.bind(this),
      "args": [UserID, toSet]
    });
  },

  _SetXp: async function(UserID, toSet) {
      if (!UserID || !toSet) throw new Error('SetXpSetXp function is missing parameters!')
      if (!parseInt(toSet)) throw new Error('SetXp function parameter toSet needs to be a number!')
      toSet = parseInt(toSet)

      const SetProm = new Promise(async (resolve, error) => {

        const Info = await DB.findOneAndUpdate({ userID: UserID }, { xp: toSet });
        if (Info > 0) {
          return resolve({
            userid: UserID,
            xp: toSet,
            level: Info.level
          })
        } else {

          try {
            const Info2 = await DB.create({
              userID: UserID,
              xp: 0,
              level: 0
            });
            return resolve({
              userid: UserID,
              xp: toSet,
              level: 0
            })
          } catch (e) {
            if (e.name === 'SequelizeUniqueConstraintError') {
              return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
            }
            return error(e)
          }

        }

      });
      return SetProm;
    },

    SetLevel: function(UserID, toSet) {
      return dbQueue.addToQueue({
        "value": this._SetLevel.bind(this),
        "args": [UserID, toSet]
      });
    },

    _SetLevel: async function(UserID, toSet) {
        if (!UserID || !toSet) throw new Error('SetLevel function is missing parameters!')
        if (!parseInt(toSet)) throw new Error('SetLevel function parameter toSet needs to be a number!')
        toSet = parseInt(toSet)

        const SetProm = new Promise(async (resolve, error) => {

          const Info = await DB.findOneAndUpdate({ userID: UserID }, { level: toSet });
          if (Info > 0) {
            return resolve({
              userid: UserID,
              xp: Info.xp,
              level: toSet
            })
          } else {

            try {
              const Info2 = await DB.create({
                userID: UserID,
                xp: 0,
                level: 0
              });
              return resolve({
                userid: UserID,
                xp: 0,
                level: toSet
              })
            } catch (e) {
              if (e.name === 'SequelizeUniqueConstraintError') {
                return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
              }
              return error(e)
            }

          }

        });
        return SetProm;
      },

      AddXp: function(UserID, toAdd) {
        return dbQueue.addToQueue({
          "value": this._AddXp.bind(this),
          "args": [UserID, toAdd]
        });
      },

      _AddXp: async function(UserID, toAdd) {
          if (!UserID || !toAdd) throw new Error('AddXp function is missing parameters!')
          if (!parseInt(toAdd)) throw new Error('AddXp function parameter toAdd needs to be a number!')
          toAdd = parseInt(toAdd)

          const AddProm = new Promise(async (resolve, error) => {

            const Info = await DB.findOne({ userID: UserID });
            if (Info) {

              const Info2 = await DB.findOneAndUpdate({ userID: UserID }, { xp: Info.xp + toAdd });
              if (Info2 > 0) {
                return resolve({
                  userid: UserID,
                  oldxp: Info.xp,
                  newxp: Info.xp + toAdd,
                })
              }
            }

            return resolve('User has no record in database!')

          });
          return AddProm;
        },

        AddLevel: function(UserID, toAdd) {
          return dbQueue.addToQueue({
            "value": this._AddLevel.bind(this),
            "args": [UserID, toAdd]
          });
        },

        _AddLevel: async function(UserID, toAdd) {
            if (!UserID || !toAdd) throw new Error('AddLevel function is missing parameters!')
            if (!parseInt(toAdd)) throw new Error('AddLevel function parameter toAdd needs to be a number!')
            toAdd = parseInt(toAdd)

            const AddProm = new Promise(async (resolve, error) => {

              const Info = await DB.findOne({ userID: UserID });
              if (Info) {

                const Info2 = await DB.findOneAndUpdate({ userID: UserID }, { level: Info.level + toAdd });
                if (Info2 > 0) {
                  return resolve({
                    userid: UserID,
                    oldlevel: Info.level,
                    newlevel: Info.level + toAdd,
                  })
                }
                return error('Something went wrong in function AddLevel')
              }

              return resolve('User has no record in database!')

            });
            return AddProm;
          },

          Delete: function(UserID) {
            return dbQueue.addToQueue({
              "value": this._Delete.bind(this),
              "args": [UserID]
            });
          },

          _Delete: async function(UserID) {
            if (!UserID) throw new Error('Delete function is missing parameters!')

            const DeleteProm = new Promise(async (resolve, error) => {

              const Info = await DB.deleteOne({ userID: UserID });
              if (Info) {
                return resolve({
                  deleted: true
                })
              }

              return resolve({
                deleted: false
              })

            });
            return DeleteProm;
          },

          Fetch: function(UserID) {
            return dbQueue.addToQueue({
              "value": this._Fetch.bind(this),
              "args": [UserID]
            });
          },

          _Fetch: async function(UserID) {
              if (!UserID) throw new Error('Fetch function is missing parameters!')
              const FetchProm = new Promise(async (resolve, error) => {

                const Info = await DB.findOne({ userID: UserID });
                if (Info) {
                  return resolve({
                    userid: Info.userID,
                    xp: Info.xp,
                    level: Info.level
                  })
                }
                try {
                  const Info2 = await DB.create({
                    userID: UserID,
                    xp: 0,
                    level: 0
                  });
                  return resolve({
                    userid: UserID,
                    xp: 0,
                    level: 0
                  })
                } catch (e) {
                  if (e.name === 'SequelizeUniqueConstraintError') {
                    return resolve(`Duplicate Found, shouldn\'t happen in this function, check typo\'s`)
                  }
                  return error(e)
                }
              });
              return FetchProm;
            },

            Leaderboard: function(data = {}) {
              return dbQueue.addToQueue({
                "value": this._Leaderboard.bind(this),
                "args": [data]
              });
            },

            _Leaderboard: async function(data) {
              if (data.limit && !parseInt(data.limit)) throw new Error('Leaderboard function parameter obj.limit needs to be a number!')
              if (data.limit) data.limit = parseInt(data.limit)
              const LeaderboardProm = new Promise(async (resolve, error) => {

                if (data.limit) {

                  if (data.search) {

                    const Info = await DB.find({
                        xp: {
                          $gt: 0
                        },
                        level: {
                          $gt: 0
                        }
                      }).limit(data.limit)

                    let output = Info.map(l => l.userID + ' ' + l.level + ' ' + l.xp).sort((a, b) => {

                      if (b.split(' ')[1] < a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return -1;
                      if (b.split(' ')[1] > a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return 1;

                      if (b.split(' ')[2] < a.split(' ')[2]) return -1;
                      if (b.split(' ')[2] > a.split(' ')[2]) return 1;

                    }).findIndex(l => l.split(' ')[0] == data.search)

                    if (output == -1) return resolve('Not found')
                    return resolve({
                      userid: UserID,
                      placement: output + 1
                    })

                  } else {

                    const Info = await DB.find({
                        xp: {
                          $gt: 0
                        },
                        level: {
                          $gt: 0
                        }
                      }).limit(data.limit)

                    let output = Info.map(l => l.userID + ' ' + l.level + ' ' + l.xp).sort((a, b) => {

                      if (b.split(' ')[1] < a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return -1;
                      if (b.split(' ')[1] > a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return 1;

                      if (b.split(' ')[2] < a.split(' ')[2]) return -1;
                      if (b.split(' ')[2] > a.split(' ')[2]) return 1;

                    }).map(l => new Object({
                      userid: l.split(' ')[0],
                      level: l.split(' ')[1],
                      xp: l.split(' ')[2]
                    }))

                    return resolve(output)

                  }

                } else {

                  if (data.search) {

                    const Info = await DB.find({
                        xp: {
                          $gt: 0
                        },
                        level: {
                          $gt: 0
                        }
                      })

                    let output = Info.map(l => l.userID + ' ' + l.level + ' ' + l.xp).sort((a, b) => {

                      if (b.split(' ')[1] < a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return -1;
                      if (b.split(' ')[1] > a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return 1;

                      if (b.split(' ')[2] < a.split(' ')[2]) return -1;
                      if (b.split(' ')[2] > a.split(' ')[2]) return 1;

                    }).findIndex(l => l.split(' ')[0] == data.search)

                    if (output == -1) return resolve('Not found')
                    return resolve({
                      userid: UserID,
                      placement: output + 1
                    })

                  } else {

                    const Info = await DB.find({
                        xp: {
                          $gt: 0
                        },
                        level: {
                          $gt: 0
                        }
                      })

                    let output = Info.map(l => l.userID + ' ' + l.level + ' ' + l.xp).sort((a, b) => {

                      if (b.split(' ')[1] < a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return -1;
                      if (b.split(' ')[1] > a.split(' ')[1] && a.split(' ')[2] != b.split(' ')[2]) return 1;

                      if (b.split(' ')[2] < a.split(' ')[2]) return -1;
                      if (b.split(' ')[2] > a.split(' ')[2]) return 1;

                    }).map(l => new Object({
                      userid: l.split(' ')[0],
                      level: l.split(' ')[1],
                      xp: l.split(' ')[2]
                    }))


                    return resolve(output)

                  }

                }

              });
              return LeaderboardProm;
            }

}
